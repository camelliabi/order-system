package com.camellia.ordersystem.dto;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Regression test suite for MenuItemDTO encapsulation bug fix.
 * Generated by Test Generator / Regression Guard agent.
 * 
 * Bug: MenuItemDTO had inconsistent field encapsulation - 5 PUBLIC fields
 * and 1 PRIVATE field, violating JavaBeans specification.
 * 
 * Root Cause: Lack of enforced architectural standards for DTO design,
 * insufficient understanding of JavaBeans conventions.
 * 
 * These tests ensure:
 * 1. All fields are private (encapsulation)
 * 2. All getters exist and return correct types
 * 3. All setters exist and accept correct types
 * 4. Boolean field uses primitive type consistently
 * 5. JavaBeans specification compliance
 * 6. Getter/setter round-trip consistency
 * 7. Null value handling for optional fields
 * 8. Complex type (Map) integrity
 */
@DisplayName("MenuItemDTO Regression Tests - Encapsulation & JavaBeans Compliance")
class MenuItemDTOTest {

    @Test
    @DisplayName("All fields must be private to enforce encapsulation")
    void testAllFieldsArePrivate() {
        Field[] fields = MenuItemDTO.class.getDeclaredFields();
        
        for (Field field : fields) {
            assertTrue(
                Modifier.isPrivate(field.getModifiers()),
                "Field '" + field.getName() + "' must be private but was " + 
                Modifier.toString(field.getModifiers())
            );
        }
        
        // Ensure we're actually testing something
        assertTrue(fields.length >= 6, "Expected at least 6 fields in MenuItemDTO");
    }

    @Test
    @DisplayName("All fields must have corresponding getter methods")
    void testAllGettersExist() throws NoSuchMethodException {
        // Test Integer field getter
        Method getItemId = MenuItemDTO.class.getMethod("getItemId");
        assertEquals(Integer.class, getItemId.getReturnType());
        
        // Test String field getter
        Method getItemName = MenuItemDTO.class.getMethod("getItemName");
        assertEquals(String.class, getItemName.getReturnType());
        
        // Test BigDecimal field getter
        Method getItemPrice = MenuItemDTO.class.getMethod("getItemPrice");
        assertEquals(BigDecimal.class, getItemPrice.getReturnType());
        
        // Test boolean field getter (must use 'is' prefix)
        Method isSoldout = MenuItemDTO.class.getMethod("isSoldout");
        assertEquals(boolean.class, isSoldout.getReturnType());
        
        // Test Map<String, BigDecimal> field getters
        Method getOptions = MenuItemDTO.class.getMethod("getOptions");
        assertEquals(Map.class, getOptions.getReturnType());
        
        Method getNotes = MenuItemDTO.class.getMethod("getNotes");
        assertEquals(Map.class, getNotes.getReturnType());
    }

    @Test
    @DisplayName("Soldout field must use primitive boolean type consistently")
    void testSoldoutTypeConsistency() throws NoSuchFieldException, NoSuchMethodException {
        // Verify field is primitive boolean
        Field soldoutField = MenuItemDTO.class.getDeclaredField("soldout");
        assertEquals(boolean.class, soldoutField.getType(), 
            "Field 'soldout' must be primitive boolean, not Boolean wrapper");
        
        // Verify getter returns primitive boolean
        Method getter = MenuItemDTO.class.getMethod("isSoldout");
        assertEquals(boolean.class, getter.getReturnType(),
            "Getter isSoldout() must return primitive boolean");
        
        // Verify setter accepts primitive boolean
        Method setter = MenuItemDTO.class.getMethod("setSoldout", boolean.class);
        assertEquals(void.class, setter.getReturnType());
        assertEquals(1, setter.getParameterCount());
        assertEquals(boolean.class, setter.getParameterTypes()[0],
            "Setter setSoldout() must accept primitive boolean");
    }

    @Test
    @DisplayName("Getter/setter round-trip must preserve values")
    void testGetterSetterConsistency() {
        MenuItemDTO dto = new MenuItemDTO();
        
        // Test Integer field
        Integer testId = 42;
        dto.setItemId(testId);
        assertEquals(testId, dto.getItemId(), "ItemId round-trip failed");
        
        // Test String field
        String testName = "Test Item";
        dto.setItemName(testName);
        assertEquals(testName, dto.getItemName(), "ItemName round-trip failed");
        
        // Test BigDecimal field
        BigDecimal testPrice = new BigDecimal("19.99");
        dto.setItemPrice(testPrice);
        assertEquals(testPrice, dto.getItemPrice(), "ItemPrice round-trip failed");
        
        // Test boolean field
        dto.setSoldout(true);
        assertTrue(dto.isSoldout(), "Soldout round-trip failed for true");
        dto.setSoldout(false);
        assertFalse(dto.isSoldout(), "Soldout round-trip failed for false");
        
        // Test Map fields
        Map<String, BigDecimal> testOptions = Map.of("Size", new BigDecimal("2.50"));
        dto.setOptions(testOptions);
        assertEquals(testOptions, dto.getOptions(), "Options round-trip failed");
        
        Map<String, BigDecimal> testNotes = Map.of("Extra", new BigDecimal("1.00"));
        dto.setNotes(testNotes);
        assertEquals(testNotes, dto.getNotes(), "Notes round-trip failed");
    }

    @Test
    @DisplayName("Optional fields must handle null values correctly")
    void testNullValueHandling() {
        MenuItemDTO dto = new MenuItemDTO();
        
        // All reference-type fields should accept null
        assertDoesNotThrow(() -> dto.setItemId(null));
        assertNull(dto.getItemId(), "ItemId should be null");
        
        assertDoesNotThrow(() -> dto.setItemName(null));
        assertNull(dto.getItemName(), "ItemName should be null");
        
        assertDoesNotThrow(() -> dto.setItemPrice(null));
        assertNull(dto.getItemPrice(), "ItemPrice should be null");
        
        assertDoesNotThrow(() -> dto.setOptions(null));
        assertNull(dto.getOptions(), "Options should be null");
        
        assertDoesNotThrow(() -> dto.setNotes(null));
        assertNull(dto.getNotes(), "Notes should be null");
        
        // Boolean primitive defaults to false, not null
        assertDoesNotThrow(() -> dto.setSoldout(false));
        assertFalse(dto.isSoldout(), "Soldout should be false");
    }

    @Test
    @DisplayName("MenuItemDTO must comply with JavaBeans specification")
    void testJavaBeansCompliance() throws NoSuchMethodException {
        // 1. Must have public no-arg constructor
        Constructor<MenuItemDTO> constructor = MenuItemDTO.class.getConstructor();
        assertTrue(Modifier.isPublic(constructor.getModifiers()),
            "No-arg constructor must be public");
        
        // 2. All fields must be private
        Field[] fields = MenuItemDTO.class.getDeclaredFields();
        for (Field field : fields) {
            assertTrue(Modifier.isPrivate(field.getModifiers()),
                "Field '" + field.getName() + "' must be private for JavaBeans compliance");
        }
        
        // 3. All getters must be public
        Method[] methods = MenuItemDTO.class.getMethods();
        long getterCount = Arrays.stream(methods)
            .filter(m -> m.getName().startsWith("get") || m.getName().startsWith("is"))
            .filter(m -> m.getParameterCount() == 0)
            .filter(m -> !m.getReturnType().equals(void.class))
            .count();
        
        assertTrue(getterCount >= 6, "Expected at least 6 getter methods");
        
        // 4. All setters must be public
        long setterCount = Arrays.stream(methods)
            .filter(m -> m.getName().startsWith("set"))
            .filter(m -> m.getParameterCount() == 1)
            .filter(m -> m.getReturnType().equals(void.class))
            .count();
        
        assertTrue(setterCount >= 6, "Expected at least 6 setter methods");
    }

    @Test
    @DisplayName("Direct field access must be blocked by private modifiers")
    void testDirectFieldAccessBlocked() {
        MenuItemDTO dto = new MenuItemDTO();
        
        // Attempt to access fields directly via reflection (simulates what public access would allow)
        Field[] fields = MenuItemDTO.class.getDeclaredFields();
        
        for (Field field : fields) {
            // Fields should NOT be accessible without setAccessible(true)
            assertThrows(IllegalAccessException.class, () -> {
                field.get(dto); // This should fail for private fields
            }, "Field '" + field.getName() + "' should not be directly accessible");
        }
    }

    @Test
    @DisplayName("Map fields must maintain type safety and reference integrity")
    void testComplexTypeIntegrity() {
        MenuItemDTO dto = new MenuItemDTO();
        
        // Create test data with specific types
        Map<String, BigDecimal> options = new HashMap<>();
        options.put("Small", new BigDecimal("0.00"));
        options.put("Large", new BigDecimal("3.50"));
        
        Map<String, BigDecimal> notes = new HashMap<>();
        notes.put("Extra Cheese", new BigDecimal("1.50"));
        notes.put("No Onions", new BigDecimal("0.00"));
        
        dto.setOptions(options);
        dto.setNotes(notes);
        
        // Verify same reference is returned (not a copy)
        assertSame(options, dto.getOptions(), 
            "Options should return same reference");
        assertSame(notes, dto.getNotes(), 
            "Notes should return same reference");
        
        // Verify map contents
        assertEquals(2, dto.getOptions().size());
        assertEquals(new BigDecimal("3.50"), dto.getOptions().get("Large"));
        
        assertEquals(2, dto.getNotes().size());
        assertEquals(new BigDecimal("1.50"), dto.getNotes().get("Extra Cheese"));
        
        // Verify modifications to returned map affect the DTO
        dto.getOptions().put("Medium", new BigDecimal("1.75"));
        assertEquals(3, dto.getOptions().size(), 
            "Map modifications should be reflected in DTO");
    }

    @Test
    @DisplayName("All setters must exist with correct parameter types")
    void testAllSettersExist() throws NoSuchMethodException {
        // Test Integer field setter
        Method setItemId = MenuItemDTO.class.getMethod("setItemId", Integer.class);
        assertEquals(void.class, setItemId.getReturnType());
        
        // Test String field setter
        Method setItemName = MenuItemDTO.class.getMethod("setItemName", String.class);
        assertEquals(void.class, setItemName.getReturnType());
        
        // Test BigDecimal field setter
        Method setItemPrice = MenuItemDTO.class.getMethod("setItemPrice", BigDecimal.class);
        assertEquals(void.class, setItemPrice.getReturnType());
        
        // Test boolean field setter (must accept primitive boolean)
        Method setSoldout = MenuItemDTO.class.getMethod("setSoldout", boolean.class);
        assertEquals(void.class, setSoldout.getReturnType());
        
        // Test Map field setters
        Method setOptions = MenuItemDTO.class.getMethod("setOptions", Map.class);
        assertEquals(void.class, setOptions.getReturnType());
        
        Method setNotes = MenuItemDTO.class.getMethod("setNotes", Map.class);
        assertEquals(void.class, setNotes.getReturnType());
    }

    @Test
    @DisplayName("Default constructor must initialize object to safe state")
    void testDefaultConstructorInitialization() {
        MenuItemDTO dto = new MenuItemDTO();
        
        // Reference types should be null by default
        assertNull(dto.getItemId(), "ItemId should default to null");
        assertNull(dto.getItemName(), "ItemName should default to null");
        assertNull(dto.getItemPrice(), "ItemPrice should default to null");
        assertNull(dto.getOptions(), "Options should default to null");
        assertNull(dto.getNotes(), "Notes should default to null");
        
        // Primitive boolean defaults to false
        assertFalse(dto.isSoldout(), "Soldout should default to false");
    }
}
