package com.camellia.ordersystem.order;

import com.camellia.ordersystem.menu.MenuItem;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Regression test suite for Order.setTotalPrice() quantity multiplication bug.
 * Generated by Test Generator / Regression Guard agent.
 * 
 * Bug: setTotalPrice() was summing item prices WITHOUT multiplying by quantity,
 * while addItems() correctly included quantity multiplication.
 * 
 * Root Cause: Missing "* itm.getQuantity()" in the setTotalPrice() loop.
 * 
 * These tests ensure:
 * 1. setTotalPrice() correctly multiplies price by quantity
 * 2. Consistency between setTotalPrice() and addItems()
 * 3. Edge cases (empty orders, quantity=1, large quantities)
 * 4. Correct handling of items with price-modifying options
 */
@DisplayName("Order.setTotalPrice() Quantity Multiplication Regression Tests")
class OrderTest {

    @Test
    @DisplayName("setTotalPrice() must multiply item price by quantity (core regression)")
    void testSetTotalPriceWithMultipleQuantities_CoreRegression() {
        // Arrange: 3 Fried Rice items at $8.99 each
        MenuItem friedRice = new MenuItem(1, "Fried Rice", 8.99);
        OrderItem orderItem = new OrderItem(friedRice, 3);
        
        Order order = new Order(101, "Table 5");
        order.getOrderItems().add(orderItem);
        
        // Act
        order.setTotalPrice();
        
        // Assert: Total should be 3 × $8.99 = $26.97
        assertEquals(26.97, order.getTotalPrice(), 0.01,
            "Total price must account for quantity (3 items × $8.99 = $26.97)");
        
        // Before fix: Would return 8.99 (missing quantity multiplication)
        // After fix: Returns 26.97 (correct calculation)
    }

    @Test
    @DisplayName("setTotalPrice() and addItems() must produce consistent totals")
    void testSetTotalPriceConsistencyWithAddItems() {
        // Arrange: Multiple items with varying quantities
        MenuItem noodles = new MenuItem(1, "Noodles", 12.50);
        MenuItem rice = new MenuItem(2, "Rice", 8.99);
        MenuItem tea = new MenuItem(3, "Tea", 3.50);
        
        OrderItem item1 = new OrderItem(noodles, 2);
        OrderItem item2 = new OrderItem(rice, 3);
        OrderItem item3 = new OrderItem(tea, 1);
        
        // Order A: Use addItems() to calculate total
        Order orderA = new Order(101, "Table 1");
        orderA.addItems(List.of(item1, item2, item3));
        double totalViaAddItems = orderA.getTotalPrice();
        
        // Order B: Manually add items, then call setTotalPrice()
        Order orderB = new Order(102, "Table 2");
        orderB.getOrderItems().add(item1);
        orderB.getOrderItems().add(item2);
        orderB.getOrderItems().add(item3);
        orderB.setTotalPrice();
        double totalViaSetTotalPrice = orderB.getTotalPrice();
        
        // Assert: Both methods must produce identical totals
        assertEquals(totalViaAddItems, totalViaSetTotalPrice, 0.01,
            "setTotalPrice() and addItems() must calculate identical totals for the same items");
        
        // Expected: (2×12.50) + (3×8.99) + (1×3.50) = 25.00 + 26.97 + 3.50 = 55.47
        assertEquals(55.47, totalViaSetTotalPrice, 0.01);
    }

    @Test
    @DisplayName("setTotalPrice() must handle varying quantities correctly")
    void testSetTotalPriceWithVaryingQuantities() {
        // Arrange: Items with quantities 1, 5, and 10
        MenuItem item1 = new MenuItem(1, "Item A", 10.00);
        MenuItem item2 = new MenuItem(2, "Item B", 5.00);
        MenuItem item3 = new MenuItem(3, "Item C", 2.50);
        
        Order order = new Order(101, "Table 1");
        order.getOrderItems().add(new OrderItem(item1, 1));   // 1 × 10.00 = 10.00
        order.getOrderItems().add(new OrderItem(item2, 5));   // 5 × 5.00 = 25.00
        order.getOrderItems().add(new OrderItem(item3, 10));  // 10 × 2.50 = 25.00
        
        // Act
        order.setTotalPrice();
        
        // Assert: Total = 10.00 + 25.00 + 25.00 = 60.00
        assertEquals(60.00, order.getTotalPrice(), 0.01,
            "Total must correctly multiply each item's price by its quantity");
    }

    @Test
    @DisplayName("setTotalPrice() must multiply (base price + options) by quantity")
    void testSetTotalPriceWithItemsHavingOptions() {
        // Arrange: Item with base price $10.00 and option adding $2.00
        MenuItem noodles = new MenuItem(1, "Noodles", 10.00);
        Map<String, Double> options = new HashMap<>();
        options.put("Extra Spicy", 2.00);
        noodles.setOptions(options);
        
        OrderItem orderItem = new OrderItem(noodles, 4);
        orderItem.setChosenOption("Extra Spicy");
        
        Order order = new Order(101, "Table 1");
        order.getOrderItems().add(orderItem);
        
        // Act
        order.setTotalPrice();
        
        // Assert: Total = 4 × (10.00 + 2.00) = 4 × 12.00 = 48.00
        assertEquals(48.00, order.getTotalPrice(), 0.01,
            "Total must multiply the full item price (including options) by quantity");
    }

    @Test
    @DisplayName("setTotalPrice() must handle empty orders gracefully")
    void testSetTotalPriceWithEmptyOrder() {
        // Arrange: Order with no items
        Order order = new Order(101, "Table 1");
        
        // Act
        order.setTotalPrice();
        
        // Assert: Total should be 0.00
        assertEquals(0.00, order.getTotalPrice(), 0.01,
            "Empty order must have total price of 0.00");
    }

    @Test
    @DisplayName("setTotalPrice() must work correctly even when all quantities are 1")
    void testSetTotalPriceWithSingleQuantityItems() {
        // Arrange: Three items, each with quantity 1
        MenuItem item1 = new MenuItem(1, "Item A", 5.00);
        MenuItem item2 = new MenuItem(2, "Item B", 7.50);
        MenuItem item3 = new MenuItem(3, "Item C", 3.25);
        
        Order order = new Order(101, "Table 1");
        order.getOrderItems().add(new OrderItem(item1, 1));
        order.getOrderItems().add(new OrderItem(item2, 1));
        order.getOrderItems().add(new OrderItem(item3, 1));
        
        // Act
        order.setTotalPrice();
        
        // Assert: Total = 5.00 + 7.50 + 3.25 = 15.75
        assertEquals(15.75, order.getTotalPrice(), 0.01,
            "Total must be correct even when all quantities are 1");
    }

    @Test
    @DisplayName("setTotalPrice() must handle large quantities without precision loss")
    void testSetTotalPriceWithLargeQuantity() {
        // Arrange: 100 items at $1.99 each
        MenuItem item = new MenuItem(1, "Bulk Item", 1.99);
        OrderItem orderItem = new OrderItem(item, 100);
        
        Order order = new Order(101, "Table 1");
        order.getOrderItems().add(orderItem);
        
        // Act
        order.setTotalPrice();
        
        // Assert: Total = 100 × 1.99 = 199.00
        assertEquals(199.00, order.getTotalPrice(), 0.01,
            "Total must correctly handle large quantities");
    }
}
